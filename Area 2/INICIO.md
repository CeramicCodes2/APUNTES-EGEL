
PREGUNTAS 203

143 DISCIPLINAR
120 

15% REACTIVOS PILOTOS QUE NO SE CONSIDERAN PARA LA CALIFICACION

203 * 0.15 = 234

72% preguntas disciplinares

1) analissi de software
2) dise;o
3) desarollo
4) gestion de proyectos

transversal

1) comprencion lectora 
2) redaccion indirecta

### analisis de sistemas de software 22
### area de dise;o de software 32
### area de desarollo 50 preguntas
### area de gestion 30


### EXAMEN A SELECCIONAR ISOFT PLUS

### 14000, 9001


# COSAS QUE ESTUDIAR

>-  ing de requerimientos
>- iso ieee ,estandares de calidad 9126,*14k*,*25001*,
>- modelado de bd (*alpha*)
>- temas de arq de software 
>- calculo de metricas *biene mucho*, *COCOMO estandar mas popular para estimar costos HORAS HOMBRES,LINEAS DE CODIGO*
>- identificacion de errores
>- IDE -> ENTORNO DE DESAROLLO INTEGRADO 
>- emuladores de software para android
>- *ahora si viene*
>- METODOGLOIAS -> AGILES ORIENTADAS, AGILES , 
>- AGILES -> SCRUP XP CANVAN 
>- ORIENTADAS A OBJETOS -> POR DIAGRAMAS COMO *UML* CASOS DE USO *UML UNIFIED MODEL LENGUAJE* METODOLOGIA USADA EN EL ADY DESAROLLO ORIENTADO A OBJETOS
>-  TIPOS DE ARQUITECTURA
>	- EMPRESARIAL (MUY GENERAL)
>	- SOLUCION (POR EJEMPLO HACER LA CASA ES DECIR LA ARQUITECTURA DE LA SOLUCION)
>	- TECNICA ( APRTE DEL CODIGO POR EJEMPLO)

#### PATRONES ARQUITECTONICOS DE SOFTWARE
https://www.bing.com/search?q=patrones+arquitect%C3%B3nicos+de+software&cvid=940ae28fcf6b463babef36046138f84f&gs_lcrp=EgZjaHJvbWUqBggBEAAYQDIGCAAQRRg5MgYIARAAGEAyBggCEAAYQNIBCDQwNTJqMGo5qAIAsAIA&FORM=ANAB01&PC=ASTS
SINGLETON -> PATRON DE DISE;O ARQUITECTONICO TECNICO

modelos arquitectonicos

singleton de que parte del SDLC es -> desarollo o dise;o


FORMULAS PARA SACAR PERT -> DIAGRAMAS
	DIAGRAMA DE *PERT* (con circulos)
	 DIAGRAMA DE *GANT* ( el de las barras que se conectan con flechas)
*formulas de rutas criticas*
y detectar actividades importantes 

formulas para sacar pert


diagramas de casos de uso DE QUE PARTE ES -> ANALISIS (documentacion de req)

node js aplicar js en el lado del 


framework -> marcan una estructura o forma de utilizar ejemplo .net 
te marcan una forma de trabajar marcan un patron para utilizarlo

libreria -> conjunto de codigo que sirve para realizar cosas

proto.io -> pagina para hacer prototipos

![[Pasted image 20240129210331.png]]

### IDES
Bluej -> 
INTELLIJ -> IDE PROGRAMAR EN JAVA
ZONJAL ->

# ATAM

![[Pasted image 20240129210537.png]]



23-1

MODELO MVC

Metodo Mosscou


buscar trabajo en funcion de cuanto van a pagar etc
mvc patron que permite dividir en capas

hay mas del modelo MVC


METODO MOSSCOU 


![[Pasted image 20240129212856.png]]

El esquema de priorización MoSCoW utiliza las cuatro letras mayúsculas para representar cuatro posibles clasificaciones de prioridad para los requisitos en un conjunto (IIBA 2009):

Must (Debe): El requisito debe cumplirse para que la solución se considere un éxito.
Should (Debería): El requisito es importante y debería incluirse en la solución si es posible, pero no es obligatorio para el éxito.
Could (Podría): Es una capacidad deseable, pero que podría posponerse o eliminarse. Impleméntelo solo si el tiempo y los recursos lo permiten.
Won't (No): Esto indica un requisito que no se implementará en este momento, pero que podría incluirse en una versión futura.
El esquema MoSCoW cambia la escala de tres niveles de alta, media y baja a una escala de cuatro niveles. No ofrece ninguna justificación para tomar la decisión sobre cómo clasificar la prioridad de un requisito en comparación con otros. MoSCoW es ambiguo en cuanto al tiempo, especialmente en lo que respecta a la calificación de "Won't" (No). "Won't" podría significar "no en la próxima versión" o "nunca". Tales distinciones deben quedar claras para que todas las partes interesadas compartan una comprensión común de las implicaciones de una calificación de prioridad particular. La escala de tres niveles descrita anteriormente, que se basa en el análisis de las dos dimensiones de importancia y urgencia, y se enfoca específicamente en la próxima versión o marco de tiempo de desarrollo, es una forma más clara de pensar en las prioridades. No recomendamos el uso de MoSCoW.


p2p ES UN ESTILO ARQUITECTONICO arquitectura mas generica mas abstracta 

frameworks para ARQUITECTURA EMPRESARIAL  ( arquitectura global de toda la empresa)
>- 4+1 framework o modelo de arq empresarial
>- TOGAB



>- arq empresarial
>- arq de solucion -> estlos arq y patrones arq
>	- estilos arq monolitico p2p soa ddd tdd clean
>	- patrones de estilos arq mvc rest soap mvvm pm -> presentacion modelo
>- arq tecnica


*iso 15000
9126* si vienen



estandares de calidad de proceso
CMMI

paradigmas

LMS -> plataformas donde hay informacion de aprendisaje pegado a ello esta el CRM

ERP -> ES EL SOFTWARE QUE TIENE TODOS LOS MODULOS COMO FINANSAS

BI -> BUSSINES INTELIGENCE


pseudocodigo

plataformas de desarollo o ides

SAM -> 


sacar costos -> cocomo estudiar formulas

control de riesgos -> que es control de riesgos

arboles de decision -> para tomar desciiones buenas

licencias de oracle -> ( a lo menos son como opensource, mit,tipos de software de renta lisencia )
diagramas de clase -> 

lenguaje c
computo en ala nube

cocomo

prolog

![[Pasted image 20240129213846.png]]

ver como funciona ( es un lenguaje de sexta generacion igual que sql)


uso de firewall
privilegios de usuarios -> permisos


# TIPOS DE NUBE

>- PUBLICA 
>- PRIVADA
>- HYBRIDA

DIFERENCIAS

# PUBLICA
LO ADMINISTRA UN TERCERO
SOLO PAGAS LO QUE TE DAN

SE DICE **PUBLICA POR QUE CUALQUIERA PUEDE CONTRATARLO**

# PRIVADA
ES LA NUBE DE UNA EMPRESA

USAR O NO SE COMPRARON SERVIDORES LUZ ETC

SE DICE PRIVADA POR QUE ES SOLO PARA LA EMPRESA ES DECIR ES INTRANET
# HYBRIDA
ES UNA COMBINACION ENTRE LAS DOS


LA DIFERENCIA ENTONCES ENTRE LOS TIPOS DE NUBE ES QUIEN LA ADMINISTRA

DIFERENCIA ENTRE SITE Y COMPUTO EN LA NUBE
EL COMPUTO EN LA NUBE ES ATRAVEZ DE INTERNET
EL SITE NO


# SAAS

APLICACIONES LISTAS PARA CONSUMO DEL USUSARIO

SOFTWARE AS A SERVICE



# PAAS
RENTAN LA PLATAFORMA PARA INSTALAR TU SOFTWARE Y SE RENTE A LAS PERSONAS COMO SAAS
ESTA EN GENERAL **MAS ENFOCADO A DESAROLLADORES**




# IAAS


EN POCAS PALABRAS ES UN SEVIDOR EN LA NUBE
PUEDES GESTIONAR LA MEMORIA RAM


![[Pasted image 20240201203651.png]]

![[Pasted image 20240201203734.png]]



# COCOMO



# PROLOG

# MOSSOCU

# USO DE FIREWALLS

TIPOS DE FIREWALLS:

>- FISICO
>- HARDWARE

>- LOS DE HARDWARE -> BLOQUEAN PUERTOS (FISICOS)
>- LOS DE SOFTWARE -> BLOQUEAN APLICACIONES O SERVICIOS

# arq agiles como xp
# casos de uso
# gestion de riesgos

>[!important] PLAN O DOCUMENTO DE RECUPERACION ANTE DESASTRES
>investigar

### SLA 
![[Pasted image 20240201205813.png]]

![[Pasted image 20240201205847.png]]


#### SLA BASADO EN CLIENTE


En otras palabras, es cuando existe un SLA que cubre muchos servicios para el mismo cliente o área de negocio.


#### SLA BASADO EN SERVICIOS:

Un SLA basado en el servicio cubre el nivel de servicio para todos los clientes, no solo para uno.

Una empresa SaaS, por ejemplo, puede utilizar un SLA basado en servicios para garantizar un tiempo de actividad del 99,9% para su producto y ofrecer créditos de servicio en caso de incumplimiento. 


https://discover.egafutura.com/que-es-un-sla-definicion-ejemplos-y-consejos-para-pequenas-empresas/#:~:text=SLA%20basado%20en%20servicios%20Un%20SLA%20basado%20en,ofrecer%20cr%C3%A9ditos%20de%20servicio%20en%20caso%20de%20incumplimiento.



#### SLA MULTINIVEL 


Los acuerdos de servicio multinivel le permiten ajustar o combinar diferentes tipos de SLA para satisfacer las necesidades de sus clientes.

El ejemplo más simple de este tipo existe en muchos productos de software freemium. A menudo verá niveles de servicio garantizados 


# gestion de riesgos estudiar


# planning poker

![[Pasted image 20240201210419.png]]

![[Pasted image 20240201210618.png]]


### la mejor forma de estimacione sla basada en expertis

https://xherpatothegenius.com/planning-poker/


09 Ene ¿Qué es el Planning Poker y por qué es tan eficaz?
Tenemos que realizar un proyecto y sabemos cuáles son las tareas necesarias para llevarlo a cabo. Sin embargo, ¿cómo estimamos el tiempo que vamos a necesitar para hacer cada una de ellas? ¿Existe un mejor criterio para priorizar una lista de tareas? Ante dos tareas que a priori parecen sencillas, escoger cual se prioriza o la metodología con la que se aborda puede no serlo en absoluto.

El Planning Poker se ha convertido en un ritual de los proyectos ágiles. Es una herramienta rápida y sencilla que sirve para estimar el esfuerzo de las tareas que integran un proyecto contando con la participación de todos los implicados.

¿Cómo se juega al Planning Poker?
La idea es simple. El equipo se reúne en presencia del Product Owner, quien expone las tareas que se quieren estimar. Cada miembro del equipo posee un juego de cartas con valores numéricos basados en la serie de Fibonaci. Una vez expuesta la primera tarea, cada miembro selecciona una carta, su estimación personal, y la coloca boca abajo sobre la mesa. Cuando todos están listos, la voltean y observan los resultados.

Los miembros del equipo con la valoración máxima y mínima justifican el porqué de su razonamiento. Después de debatir la situación, el equipo puede buscar la convergencia hacia una estimación de consenso jugando una o más rondas adicionales. Para no hacer eterno el juego si el equipo no alcanza la unanimidad, el resultado será la media. Supongamos que le han encargado a tu equipo (3 miembros) pintar el interior de una casa: un dormitorio, una cocina y un baño. Por el tamaño, la votación del baño es unánime (3,3,3). El dormitorio, algo más amplio, ha sido valorado por cada persona 5,6 y 7, dando lugar a un resultado medio de 6,5 puntos. La cocina ha generado más controversia (2,8,13). La persona con la valoración mínima, argumenta que el espacio de pared que hay que pintar es incluso más pequeño que el del dormitorio. Sin embargo, su compañero justifica que antes de pintar, se deben cubrir todos los muebles y, por el diseño, deberían utilizar una brocha y no un rodillo. En la nueva votación, quien había votado un dos pasó a valorar un ocho.


## tipos de escalamiento

## vertical 
aumentar procesador y ram **aumentar la potencia del servidor**
## horizontal
utilizar otro servidor **agregar mas instancias**

##  fragmentacion vertical y horizontal

La **fragmentación** en bases de datos distribuidas es un proceso mediante el cual una **relación global** se divide en fragmentos más pequeños. Estos fragmentos pueden ser **horizontales** o **verticales**. Permíteme explicarte en detalle:

1. **Fragmentación Horizontal (H)**:
   - Divide la tabla en función de las **filas**.
   - Cada fragmento contiene un subconjunto de tuplas.
   - Para que la fragmentación horizontal sea correcta, se deben cumplir tres normas:
     - La **unión** de todos los fragmentos debe ser igual a la relación original.
     - La **intersección** de todos los fragmentos debe ser vacía.
     - La relación original se puede recuperar mediante la **unión** de los fragmentos.
   - Ejemplo: Si tenemos una tabla de alumnos, podríamos fragmentarla horizontalmente por el campo "unidad", almacenando cada fragmento en una unidad específica¹.

2. **Fragmentación Vertical (V)**:
   - Divide las tablas en función de las **columnas**.
   - Cada fragmento contiene un subconjunto de atributos.
   - Ejemplo: Si tenemos una tabla de empleados con atributos como nombre, salario y departamento, podríamos fragmentarla verticalmente para almacenar los nombres en un fragmento, los salarios en otro y los departamentos en otro³.

En resumen, la fragmentación es como la partición de grandes tablas en fragmentos más manejables, ya sea por filas o por columnas. Cada tipo de fragmentación tiene sus ventajas y desafíos, y se utiliza según las necesidades específicas del sistema distribuido²⁴. 🌐🔍

Origen: Conversación con Bing, 1/2/2024
(1) Base de datos distribuidas - Universidad Autónoma Metropolitana. http://aisii.azc.uam.mx/areyes/archivos/Licenciatura/BDD/FragmentacionHorizontal.pdf.
(2) Una Guía Para Entender la Fragmentación de las Bases de Datos - Kinsta. https://kinsta.com/es/blog/fragmentacion-de-la-base-de-datos/.
(3) FRAGMENTACIÓN VERTICAL Y ASIGNACIÓN SIMULTANEA EN BDD USANDO ALGORITMOS .... https://bing.com/search?q=fragmentaci%c3%b3n+horizontal+y+vertical.
(4) Un Método para la Fragmentación Vertical de Bases de Datos y su .... http://sedici.unlp.edu.ar/bitstream/handle/10915/23741/Documento_completo.pdf?sequence=1.


# cocomo

# Profesor Octavio César Escobar Jaramillo
Constructive Cost Model, es un modelo matemático de base empírica utilizado para estimación de costos de software. Fue desarrollado por Barry Boehm en la década de 1970 y se ha utilizado en una amplia gama de proyectos de software, desde pequeños proyectos de desarrollo interno hasta grandes proyectos de desarrollo comercial. El primer punto a considerar con COCOMO es la evaluación que hace a los modelos de desarrollo o tipos de proyecto bajo el siguiente esquema:

• Orgánico: proyectos relativamente sencillos, menores de 50 KDLC líneas de código, en los cuales se tiene experiencia de proyectos similares y se encuentran en entornos estables.
• Semi-acoplado: proyectos intermedios en complejidad y tamaño (menores de 300 KDLC), donde la experiencia en este tipo de proyectos es variable, y las restricciones intermedias.
• Empotrado: proyectos bastante complejos, en los que apenas se tiene experiencia y se engloban en un entorno de gran innovación técnica. Además se trabaja con unos requisitos muy restrictivos y de gran volatilidad.


### (sistemas basico intrmedio y acoplado)


COCOMO se basa en la idea de que el costo de un proyecto de software está relacionado con su tamaño. El tamaño se mide en función de la cantidad de líneas de código (LOC) que se espera que tenga el producto final. COCOMO utiliza tres submodelos, cada uno de los cuales ofrece un nivel de detalle y aproximación, cada vez mayor, a medida que avanza el proceso de desarrollo del software:

• COCOMO Básico: Este modelo es el más simple y se utiliza para estimar el costo de proyectos pequeños y medianos. Se basa exclusivamente en el tamaño expresado en líneas de código (LDC).
• COCOMO Intermedio: Este modelo es más complejo y se utiliza para estimar el costo de proyectos de tamaño mediano a grande. Además del tamaño del programa, incluye un conjunto de medidas subjetivas llamadas conductores de costes.
• COCOMO Detallado: Este modelo es el más complejo y se utiliza para estimar el costo de proyectos de gran tamaño. Incluye todo lo del modelo intermedio además del impacto de cada conductor de coste en las distintas fases de desarrollo.
• La experiencia del equipo: COCOMO tiene en cuenta la experiencia del equipo de desarrollo, como el número de años de experiencia que tiene el equipo en el desarrollo de software similar.
• La complejidad del software: COCOMO tiene en cuenta la complejidad del software, como el número de características y requisitos que tendrá el software.

COCOMO es una herramienta valiosa para estimar el costo de los proyectos de software. Sin embargo, es importante tener en cuenta que COCOMO es un modelo estadístico y, como tal, no es perfecto. Los resultados de COCOMO deben utilizarse como una guía y deben ajustarse en función de la experiencia y el conocimiento del equipo de desarrollo.

Algunos de los beneficios de utilizar COCOMO son:

• Ayuda a los equipos de desarrollo a estimar el costo de los proyectos de software con mayor precisión.
• Proporciona una base para la planificación y el control del presupuesto.
• Ayuda a los equipos de desarrollo a identificar los riesgos potenciales y tomar medidas para mitigarlos.

## Ejemplo
El modelo básico de COCOMO se define como:
$$E = a \cdot (KLOC)^b$$
Donde:
- $E$ es el esfuerzo aplicado en personas-mes. ( el tiempo que te vas a tardar en hacer la chamba)
- $a$ y $b$ son constantes que dependen del tipo de proyecto (mencionado previamente: orgánico, semiacoplado, empotrado).
- $KLOC$ es el tamaño estimado del software en miles de líneas de código.

Por ejemplo, si tienes un proyecto orgánico (proyectos pequeños con buenos equipos y menos restricciones) con un tamaño de $32\ KLOC$, puedes usar los coeficientes $a=2.4$ y $b=1.05$ para el modelo orgánico. Entonces, el esfuerzo $E$ se calcularía como:
$$E = 2.4 \cdot (32)^{1.05}$$
Este cálculo te dará una estimación del esfuerzo en personas-mes. Para obtener el tiempo de desarrollo y el costo, puedes usar las siguientes ecuaciones:
$$D = c ∗(E)^d$$
$$C = \frac{E}{D}$$


Donde $D$ es el tiempo de desarrollo en meses, $c$ y $d$ son constantes que también dependen del tipo de proyecto, y $C$ es el costo por mes.

Tomar en cuenta que estas son solo estimaciones y los valores reales pueden variar dependiendo de muchos factores como la complejidad del software, la experiencia del equipo, entre otros. Además, el modelo COCOMO básico es bastante simple y no toma en cuenta muchos aspectos del desarrollo de software. Existen versiones más complejas del modelo COCOMO que pueden dar estimaciones más precisas.
# ChatGPT
COCOMO, que significa "Constructive Cost Model," es un modelo de estimación de costos de desarrollo de software. Fue desarrollado por Barry Boehm en la década de 1980 y se utiliza para estimar los recursos, el tiempo y el costo necesarios para completar un proyecto de desarrollo de software.

COCOMO se basa en tres niveles:

1. COCOMO I: Este nivel es el modelo original y se utiliza para estimar proyectos pequeños y medianos. Se basa en líneas de código de software y factores de costo como la complejidad del producto y la experiencia del equipo.

2. COCOMO II: Este nivel es una versión más sofisticada que considera una variedad de características adicionales, como el uso de tecnología avanzada, la reutilización de software y factores del entorno. COCOMO II se utiliza para proyectos más grandes y complejos.

3. COCOMO III: Es la última iteración del modelo y se centra en la estimación de proyectos de software de gran escala. Incluye factores adicionales y una mayor flexibilidad en la elección de modelos específicos para el tipo de proyecto.

En términos generales, COCOMO funciona asignando valores a diversos factores que afectan el desarrollo del software, como la complejidad del proyecto, la experiencia del equipo y las características del producto. Luego, utiliza ecuaciones matemáticas para calcular la estimación de costos y tiempo en función de estos factores.

COCOMO es una herramienta útil para la planificación y el control de proyectos de software, pero es importante recordar que las estimaciones son aproximadas y pueden variar en la práctica debido a numerosos factores imprevistos.
# Ejemplos
Aquí tienes ejemplos de cómo COCOMO se aplicaría en sus tres niveles para estimar el costo y el tiempo de desarrollo de un proyecto de software:

1. COCOMO I:
   Supongamos que estás desarrollando un pequeño sistema de gestión de inventario para una pequeña tienda. El equipo de desarrollo está compuesto por programadores con experiencia moderada. El proyecto consta de aproximadamente 10,000 líneas de código.

   Para utilizar COCOMO I, asignarías valores a factores como la complejidad del producto y la experiencia del equipo. Luego, usarías la fórmula de COCOMO I para estimar el tiempo y el costo requeridos para completar el proyecto.

2. COCOMO II:
   Ahora, imagina que estás trabajando en un proyecto más grande, como el desarrollo de un sistema de gestión de recursos empresariales (ERP). El proyecto es complejo y utiliza tecnología avanzada, con un equipo de desarrollo experimentado.

   Con COCOMO II, considerarías factores adicionales, como el reuso de componentes de software y las características del entorno. Luego, utilizarías el modelo COCOMO II adecuado para estimar el tiempo y el costo del proyecto ERP.

3. COCOMO III:
   Supongamos que estás involucrado en un proyecto a gran escala para crear un sistema de control de tráfico urbano para una ciudad metropolitana. Este proyecto es altamente complejo y se desarrollará utilizando tecnologías de vanguardia. Además, el equipo de desarrollo está distribuido en múltiples ubicaciones.

   Con COCOMO III, tendrías la flexibilidad de considerar una amplia gama de factores, como la distribución geográfica del equipo y la complejidad del entorno. Utilizarías el modelo COCOMO III adecuado para estimar el tiempo y el costo requeridos para completar el sistema de control de tráfico urbano.

En cada nivel de COCOMO, los factores específicos y las ecuaciones utilizadas varían para adaptarse a la complejidad y el alcance del proyecto, lo que permite una estimación más precisa de los recursos necesarios. Recuerda que estos son ejemplos simplificados, y en la práctica, las estimaciones requerirían un análisis más detallado y el uso de herramientas de software específicas.
# Formulas
COLOCAMOS LAS FORMULAS
1. **COCOMO I:** Este nivel se utiliza para proyectos más pequeños y se basa en la cantidad de líneas de código del software (KLOC, por sus siglas en inglés) como el principal factor. La fórmula básica es:

   Esfuerzo (E) = 2.4 * (KLOC) ^ 1.05

   Tiempo (T) = 2.5 * (E) ^ 0.38

   Costo (C) = 3.0 * (E) ^ 1.20

2. **COCOMO II: ** Este nivel es más detallado y se adapta a proyectos de mayor envergadura. Utiliza factores de escala y multiplicadores de costos. La fórmula general es:

   Esfuerzo (E) = A * (Tamaño del software) ^ B * (Factores de Escala)

   Donde A y B son valores específicos del modelo utilizado.

3. **COCOMO III: ** Este nivel es aún más complejo y se divide en varios submodelos, como el modelo de desarrollo de software de sistemas, el modelo de desarrollo de software empresarial y otros. Cada uno de estos submodelos tiene fórmulas específicas que se adaptan a la naturaleza del proyecto.

Las fórmulas específicas varían según el submodelo de COCOMO III que se utilice y dependen de una amplia variedad de factores, como la complejidad del producto, la experiencia del equipo, la reutilización de componentes de software, la distribución geográfica del equipo y otros.

Para aplicar COCOMO con precisión, es necesario utilizar una herramienta de software que tenga en cuenta todos estos factores y ecuaciones específicas, ya que la estimación manual puede ser complicada debido a la cantidad de variables involucradas.


aptana
netbains
spknet

# ide

¡Claro! Aquí tienes información sobre las herramientas que mencionaste:

1. **Aptana**:
   - **Aptana Studio 3** es un **IDE de desarrollo web de código abierto**. Aunque ya no se mantiene activamente, todavía está disponible como proyecto público en **GitHub**. Proporciona soporte para **desarrollo web**, especialmente para **Ajax/JavaScript**. Puedes descargarlo desde su repositorio en GitHub⁴⁵.

2. **NetBeans**:
   - **NetBeans IDE** es un entorno de desarrollo integrado de **código abierto y gratuito**. Es compatible con varios lenguajes de programación, como **Java, JavaScript, PHP, HTML5 y CSS**. Puedes instalarlo en sistemas operativos como **Windows, Linux, Mac OSX y BSD**¹².

3. **SPK Network**:
   - **SPK Network** es un **protocolo de redes sociales descentralizado y resistente a la censura** en la web3. Permite a las plataformas de video y a los creadores de contenido interactuar con el **grafo social descentralizado** y recompensa a los proveedores de infraestructura con tokens de gobernanza SPK y gas BROCA⁹.

4. intellij
5. Greenfoot
6. Scypiy
7. tonny
8. 

Si necesitas más detalles sobre alguna de estas herramientas, no dudes en preguntar. 🌟🔍

Origen: Conversación con Bing, 1/2/2024
(1) Aptana.com | Axway. https://www.axway.com/en/aptana.
(2) Aptana - Descargar. https://aptana.softonic.com/.
(3) Welcome to Apache NetBeans. https://netbeans.apache.org/front/main/.
(4) NetBeans IDE | Oracle México. https://www.oracle.com/mx/tools/technologies/netbeans-ide.html.
(5) SPK Network. https://spk.network/.
(6) Apache NetBeans Releases. https://netbeans.apache.org/front/main/download/index.html.
(7) Aptana Studio, un gran IDE para desarrollo - ochobitshacenunbyte. https://www.ochobitshacenunbyte.com/2015/09/14/aptana-studio-gran-ide-desarrollo/.
(8) Aptana Studio para Windows - Descarga gratis en Uptodown. https://aptana-studio.uptodown.com/windows.
(9) Aptana download | SourceForge.net. https://sourceforge.net/projects/aptana.mirror/.
(10) SKP | Internet -televisie -Telefonie. https://skpnet.nl/.
(11) SKP Webmail :: Welkom bij SKP Webmail. https://webmail.skpnet.nl/.


### iso 9001

### iso para software 9126 y 25000 y 15000

9126 -> calidad del software (usabilidad portabilidad mantenibilidad)


¡Claro! A continuación, te proporciono información sobre las normas ISO que mencionaste:

1. **ISO/IEC 9126**:
   - **ISO/IEC 9126** era un estándar internacional para la **evaluación de la calidad del software**. Sin embargo, fue reemplazado en 2005 por el conjunto de normas **SQuaRE (System and Software Quality Requirements and Evaluation)**, específicamente la norma **ISO 25000:2014**. Ambos estándares desarrollan conceptos similares.
   - La norma **ISO/IEC 9126** se basa en el modelo de calidad propuesto por McCall y sus colegas en 1977. Este modelo organiza la calidad del software en tres tipos de características:
     - **Factores**: Describen la visión externa del software desde la perspectiva del usuario.
     - **Criterios**: Describen la visión interna del software desde la perspectiva del desarrollador.
     - **Métricas**: Proporcionan una escala y método para medir la calidad.
   - La norma se divide en cuatro partes que abordan la calidad externa, interna y en uso del software¹.

2. **ISO/IEC 25000** (SQuaRE):
   - La familia de normas **ISO/IEC 25000**, conocida como **SQuaRE**, establece un marco de trabajo común para evaluar la calidad del producto software.
   - Se compone de cinco divisiones:
     - **Gestión de Calidad**: Define modelos, términos y definiciones comunes.
     - **Modelo de Calidad**: Presenta modelos detallados para calidad interna, externa y en uso.
     - **Medición de Calidad**: Incluye un modelo de referencia y guías para medir la calidad del producto.
   - La norma **ISO/IEC 25010** describe el modelo de calidad para el producto software, incluyendo características y subcaracterísticas para evaluarlo².

3. **ISO 15000**:
   - La **ISO 15000** se refiere a varios estándares relacionados con la gestión empresarial y la calidad del servicio:
     - **ISO 15000-1 (ECE 15000)**: Establece requisitos para la gestión empresarial eficiente y efectiva, enfocándose en la calidad del servicio, la mejora continua y la satisfacción del cliente.
     - **ISO 15000-2**: Específica los requisitos para un perfil de protocolo de colaboración (CPP) y un acuerdo de protocolo de colaboración (CPA) en el contexto de negocios electrónicos.
     - **ISO 22000**: Gestión de la Seguridad Alimentaria, aplicable a empresas que buscan integrar sistemas de calidad y seguridad alimentaria⁹.

En resumen, estas normas abordan aspectos clave de la calidad del software, la gestión empresarial y la seguridad alimentaria. Cada una tiene su enfoque específico y proporciona directrices para mejorar la eficacia y la satisfacción del cliente⁶⁷⁹.

Origen: Conversación con Bing, 1/2/2024
(1) NORMAS ISO 25000. https://iso25000.com/index.php/normas-iso-25000.
(2) ISO/IEC 25000 - Wikipedia, la enciclopedia libre. https://es.wikipedia.org/wiki/ISO/IEC_25000.
(3) NORMAS DE LA FAMILIA ISO ( ISO 9001, 15,000 Y 22000). https://prezi.com/9zgdrmb5a0gt/normas-de-la-familia-iso-iso-9001-15000-y-22000/.
(4) Todo lo que debes saber sobre la norma ISO 9126 para garantizar la .... https://softwarepara.es/iso-9126-calidad-de-software/.
(5) ISO 9126: La Guía Definitiva de Calidad de Software en PDF. https://softwarepara.es/iso-9126-calidad-de-software-pdf/.
(6) ISO/IEC 25000:2014 - Systems and software engineering — Systems and .... https://www.iso.org/standard/64764.html.
(7) ISO/IEC 9126 - Wikipedia, la enciclopedia libre. https://es.wikipedia.org/wiki/ISO/IEC_9126.
(8) Norma ISO 9126: Estándares para la calidad del software. https://bing.com/search?q=iso+9126.
(9) La ISO/IEC 9126: 2001: Características de la calidad de software. https://www.verity.cl/que-es-norma-iso-iec-9126-2001/.
(10) Norma ISO 15000: la clave para la excelencia en la gestión empresarial. https://bing.com/search?q=iso+15000.
(11) ISO 15000 by Heidy Yasmin Rivera Perez. https://prezi.com/-sc1h3wj9trp/iso-15000/.
(12) ISO 15000-2:2021. https://www.iso.org/standard/79109.html.
(13) La Familia ISO - Normas ISO. https://www.normas-iso.com/la-familia-iso/.


# 4+1 TOGAB
para gestion de arquitectura emprearial

### six sigma



# COCOMO

cocomo el problema de cocomo es el `m(X)`
lo mas complicado de generar por que se requerien muchos atrbutos

si es un software simple `M(X)` SE CONVIERTE EN 1

ABCD SE DAN EN EL EGEL SOLO ES SUBSTITUIR

COCOMO IDENTIFICAR:
>- SIMPLE (basico)
>- INTERMEDIO (intermedio)
>- COMPLETO(detallado | incrustado)

dependiendo de la bibliografia se daran un nombre


### RUP SE CENTRRA EN DIAGRAMAS
### RAD METODOLOGIA AGIL BASADA EN PROTOTIPOS (COMO SI FUERA UNA PROTO BOARD)
### SCRUM 

### EVALUACION DE ARQUITECTURA DE SOFTWARE:
>- ATAM 
>- ADR
>- ARID


### ISO 29129


### GWT Y JAVADOC

## PARADIGMAS DE PROGRAMACION 

>- DECLARATIVA
>- FUNCIONA
>- IMPERATIVA

UN EJERCICIO EN PROLOG

PREGUNTAS SOBRE CUANDO USAR CIERTOS LENGUAJES FRAMEWORKS ES IDE

RECOORRIDO DE PILAS Y COLAS EN C

ANALISIS CONSULTAS SQL

**ATAM** (Método de Análisis de Acuerdos de Arquitectura) es una metodología utilizada para evaluar arquitecturas de software. Aquí te proporciono información relevante sobre ATAM:

1. **Propósito de ATAM**:
   - El propósito principal de ATAM es **evaluar las consecuencias de las decisiones de arquitectura** en función de los **atributos de calidad** del sistema.
   - ATAM es un método que **identifica riesgos** y ayuda a detectar áreas de riesgo potencial dentro de la arquitectura de un sistema de software.
   - Puede aplicarse al **principio del ciclo de vida del sistema**¹.

2. **Pasos en el proceso ATAM**:
   - **Presentación del ATAM**: Se introduce el método y se establecen los objetivos.
   - **Presentación de los Conductores del Negocio**: Se identifican los requisitos no funcionales y los atributos de calidad.
   - **Caso de Negocio/Presentación de la Arquitectura**: Se presenta la arquitectura y se analizan los escenarios.
   - **Obtención y Priorización de los Escenarios**: Se evalúan las propuestas arquitectónicas en función de los atributos de calidad.
   - **Elaboración de Producto ATAM**: Se identifican riesgos, puntos de sensibilidad y áreas de concesión¹².

3. **Beneficios de utilizar ATAM**:
   - Ayuda a asegurar que se realicen las preguntas correctas relacionadas con la arquitectura desde el inicio del proyecto.
   - Facilita la comunicación precisa de las necesidades de la arquitectura y refina las decisiones de diseño.
   - Identifica tendencias y riesgos tempranos, lo que puede ahorrar costos en etapas posteriores del proyecto¹.

En resumen, ATAM es una herramienta valiosa para evaluar arquitecturas y tomar decisiones informadas que impacten positivamente en la calidad del sistema y el éxito del negocio¹³. Si tienes más preguntas o necesitas más detalles, no dudes en preguntar.


## pasar unscript a un modelo algebraico

# estudiar analisis de riesgos




# 24-1
